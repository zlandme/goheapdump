package corefile

import (
	"errors"
	"fmt"
	"reflect"
	"strings"

	"github.com/tombergan/goheapdump/debug/arch"
	"github.com/tombergan/goheapdump/debug/dwarf"
	//"golang.org/x/debug/arch"
	//"golang.org/x/debug/arch"
	//"golang.org/x/debug/dwarf"
)

// OpenProgramOptions describes options for OpenProgram.
type OpenProgramOptions struct {
	// ExecutablePath is the path to the executable that generated the core
	// file being opened. If this is empty, it is inferred from the core file.
	// If the executable path cannot be inferred from the core file, then
	// OpenProgram fails.
	ExecutablePath string

	// Writable specifies whether the core file is opened in writable mode.
	// If true, then the core file may be updated by calling Value.WriteScalar
	// or by mutating Value.Bytes. The executable file is never updated.
	// Updates to the core file may be buffered until the Program is closed.
	Writable bool

	// LoadDynamicLibraries specifies whether dynamic libraries should be
	// loaded. If false, the Program may have incomplete symbol information
	// and an incomplete representation of the virtual address space.
	// TODO: this is currently not supported
	// TODO: also support loading other memory-mapped files (besides just dynamic libs)?
	LoadDynamicLibraries bool
}

// OpenProgram opens a Program from the core file name by corepath.
// OpenProgram currently supports ELF core dumps generated by Linux.
// More file formats may be added in the future.
//
// XXX use readelf on sample corefile and execfiles to see what they have
func OpenProgram(corepath string, options *OpenProgramOptions) (*Program, error) {
	if options == nil {
		options = &OpenProgramOptions{}
	}
	coref, err := mmapOpen(corepath, options.Writable)
	if err != nil {
		return nil, err
	}
	p, err := openProgramInternal(coref, options)
	if err != nil {
		coref.Close()
		return nil, err
	}
	// Now p takes ownership of coref.
	p.filemaps = append(p.filemaps, coref)
	return p, nil
}

func openProgramInternal(coref *mmapFile, options *OpenProgramOptions) (*Program, error) {
	var p *Program
	var osthreads []*OSThread

	// Load data segments, DWARF, and other metadata from coref and execf.
	// TODO: implement for macho and pe?
	rawReaders := map[string]rawProgramReader{
		"ELF": {readELFCore, readELFExec},
	}
	var openErrs []string
	for kind, reader := range rawReaders {
		logf("OpenProgram: trying to open %s as %s", coref.Name(), kind)
		rp, err := newRawProgram(coref, options, reader)
		if err != nil {
			logf("OpenProgram: failed opening %s as %s: %v", coref.Name(), kind, err)
			openErrs = append(openErrs, fmt.Sprintf("%s: %v", kind, err))
			continue
		}
		logf("OpenProgram: opened %s with GOARCH=%s and GOOS=%s", kind, rp.goarch, rp.goos)
		p = &Program{
			GlobalVars: &VarSet{},
			RuntimeLibrary: &RuntimeLibrary{
				Arch:   goarchToArch(rp.goarch),
				GOARCH: rp.goarch,
				GOOS:   rp.goos,
				Vars:   &VarSet{},
			},
			dwarfs:       rp.dwarfs,
			dataSegments: rp.dataSegments,
			filemaps:     rp.filemaps,
		}
		p.RuntimeLibrary.Program = p
		p.RuntimeLibrary.Finalizers.p = p
		p.RuntimeLibrary.GCRoots.p = p
		p.RuntimeLibrary.HeapObjects.p = p
		osthreads = rp.osthreads
		break
	}
	if p == nil {
		return nil, fmt.Errorf("OpenProgram(%s) failed:\n\t%s", coref.Name(), strings.Join(openErrs, "\n\t"))
	}
	p.typeCache.initialize(p)

	// Load global variables from all packages.
	for fname, dw := range p.dwarfs {
		logf("OpenProgram: loading global variables from %s", fname)
		r := dw.Reader()
		for {
			e, err := r.Next()
			if err != nil {
				return nil, err
			}
			if e == nil {
				break
			}

			switch e.Tag {
			case dwarf.TagCompileUnit:
				verbosef("DWARF offset 0x%x: DW_TAG_CompileUnit with lang=%v", e.Offset, e.Val(dwarf.AttrLanguage))
				// Recurse in Go compilation units.
				const dwLangGo = 22
				if lang := e.Val(dwarf.AttrLanguage); lang != nil && reflect.ValueOf(lang).Int() == dwLangGo {
					continue
				}

			case dwarf.TagArrayType, dwarf.TagBaseType, dwarf.TagPointerType, dwarf.TagStructType,
				dwarf.TagSubroutineType, dwarf.TagTypedef, dwarf.TagUnspecifiedType:
				// Extract this type and make sure it's cached.
				dt, err := dw.Type(e.Offset)
				if err != nil {
					return nil, fmt.Errorf("could not read type at offset 0x%x: %v", e.Offset, err)
				}
				t, err := p.typeCache.addDWARF(dt)
				if err != nil {
					return nil, fmt.Errorf("could not convert type at offset 0x%x: %v", e.Offset, err)
				}
				verbosef("DWARF offset 0x%x: loaded type %s", e.Offset, t)

			case dwarf.TagVariable:
				// Extract this global variable.
				fullname := e.Val(dwarf.AttrName).(string)
				pkgPath, name := splitGlobalVariableName(fullname)

				const dwOpAddr = 3
				loc := e.Val(dwarf.AttrLocation).([]uint8)
				if len(loc) == 0 || loc[0] != dwOpAddr {
					logf("UNEXPECTED: DWARF offset 0x%x: DW_TAG_Variable %s has non-absolute location %#v",
						e.Offset, fullname, loc)
					break
				}
				addr := p.RuntimeLibrary.Arch.Uintptr(loc[1:])

				// Extract this variable's type.
				dt, err := dw.EntryType(e)
				if err != nil {
					logf("WARNING: DWARF offset 0x%x: could not read type for global var %s: %v", e.Offset, fullname, err)
					break
				}
				t := p.typeCache.findDWARF(dt)
				if t == nil {
					logf("WARNING: DWARF offset 0x%x: could not find type for global var %s, DWARF type is %s (%T)", e.Offset, fullname, dt, dt)
					break
				}

				// Create the Var.
				ds, ok := p.dataSegments.slice(addr, t.Size())
				if !ok {
					logf("WARNING: DWARF offset 0x%x: cannot find slice for global var %s at addr 0x%x", e.Offset, fullname, addr)
					break
				}
				verbosef("DWARF offset 0x%x: loaded global var %q (pkg %q, name %s) at addr 0x%x with type %s",
					e.Offset, fullname, pkgPath, name, addr, t)
				v := Var{
					Name:    name,
					PkgPath: pkgPath,
					Value: Value{
						Addr:  ds.addr,
						Type:  t,
						Bytes: ds.data,
					},
				}
				var vs *VarSet
				if pkgPath == "" || pkgPath == "runtime" || strings.HasPrefix(pkgPath, "runtime/") {
					vs = p.RuntimeLibrary.Vars
				} else {
					vs = p.GlobalVars
				}
				if err := vs.insert(v); err != nil {
					logf("DWARF offset 0x%x: %v", e.Offset, err)
				}
			}

			// Only process top-level entries in each compilation unit.
			r.SkipChildren()
		}
	}
	p.typeCache.dwarfDone = true

	// Initialize the runtime library.
	if err := p.RuntimeLibrary.initialize(osthreads); err != nil {
		return nil, err
	}
	return p, nil
}

func goarchToArch(goarch string) arch.Architecture {
	switch goarch {
	case "386":
		return arch.X86
	case "amd64":
		return arch.AMD64
	default:
		// TODO: support ppc64 and s390x
		panic(fmt.Sprintf("GOARCH: %s not supported", goarch))
	}
}

// splitPkgPathName splits fullname into pkgPath + name.
// We find the first "." that occurs after the last "/", then split on that period.
func splitPkgPathName(fullname string) (pkgPath string, name string) {
	k := strings.LastIndex(fullname, "/")
	if k < 0 {
		k = 0
	}
	d := strings.Index(fullname[k:], ".")
	if d < 0 {
		return "", fullname
	}
	return fullname[:d+k], fullname[d+k+1:]
}

// splitGlobalVariableName splits fullname into pkgPath + name.
// Like splitPkgPathName, except that internal internal variable
// names like "go.itab.*" get pkgPath = "".
func splitGlobalVariableName(fullname string) (pkgPath string, name string) {
	// "go.itab.{pkgPath.}name,type"
	if strings.HasPrefix(fullname, "go.itab.") && strings.Contains(fullname, ",") {
		return "", fullname
	}
	// "$f32.hex" and "$f64.hex"
	if strings.HasPrefix(fullname, "$f32.") || strings.HasPrefix(fullname, "$f64.") {
		return "", fullname
	}
	// "runtime/cgo(.rodata)"
	if strings.HasPrefix(fullname, "runtime/cgo(") {
		return "", fullname
	}
	return splitPkgPathName(fullname)
}

// Close closes a Program.
func (p *Program) Close() error {
	var errs []string
	for _, f := range p.filemaps {
		if err := f.Close(); err != nil {
			if f.Name() != "" {
				errs = append(errs, fmt.Sprintf("error closing mmapped file %s: %v", f.Name(), err))
			} else {
				errs = append(errs, fmt.Sprintf("error closing anon mapping: %v", err))
			}
		}
	}
	if len(errs) > 0 {
		return errors.New("error closing Program:\n\t" + strings.Join(errs, "\n\t"))
	}
	return nil
}

// rawProgramReader is the interface to reading core and executable files
// of a specific format.
type rawProgramReader struct {
	readCore func(f *mmapFile, rp *rawProgram, openWritable bool) error
	readExec func(f *mmapFile, rp *rawProgram) error
}

type rawProgram struct {
	goarch       string
	goos         string
	dataSegments dataSegments // sorted
	filemaps     []*mmapFile  // mmaps that represent data segments

	// Only set by readCore.
	execpath  string      // inferred from the core file
	osthreads []*OSThread // all threads; might include threads not managed by go (e.g., cgo threads)

	// Only set by readExec.
	dwarfs map[string]*dwarf.Data
}

func newRawProgram(coref *mmapFile, options *OpenProgramOptions, reader rawProgramReader) (out *rawProgram, finalErr error) {
	rp := &rawProgram{
		dwarfs: make(map[string]*dwarf.Data),
	}
	defer func() {
		if finalErr != nil {
			rp.Close()
		}
	}()

	// Read the core file.
	if err := reader.readCore(coref, rp, options.Writable); err != nil {
		return nil, fmt.Errorf("could not read core file: %v", err)
	}

	// Read the executable file. Prefer the path specified in options, if any.
	execpath := options.ExecutablePath
	if execpath == "" {
		execpath = rp.execpath
	}
	if execpath == "" {
		return nil, errors.New("executable path not specified and could not be inferred from the core file")
	}
	logf("OpenProgram: opening executable %s", execpath)
	execf, err := mmapOpen(execpath, false)
	if err != nil {
		return nil, err
	}
	rp.filemaps = append(rp.filemaps, execf)
	if err := reader.readExec(execf, rp); err != nil {
		return nil, fmt.Errorf("could not read executable file %s: %v", execpath, err)
	}

	// TODO: load dynamic libraries?
	return rp, nil
}

func (rp *rawProgram) Close() {
	for _, f := range rp.filemaps {
		f.Close()
	}
}

func (rp *rawProgram) insertDataSegment(addr, size uint64, makeSegment func(addr, size uint64) (dataSegment, error)) error {
	return rp.dataSegments.insert(addr, size, makeSegment)
}
